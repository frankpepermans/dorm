        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>PathObserver class / observe Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="observe" data-type="PathObserver">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Dart Documentation</a>
         &rsaquo; <a href="../observe.html">observe</a> &rsaquo; <a href="../observe/PathObserver.html">PathObserver</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>PathObserver</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<p>A data-bound path starting from a view-model or model object, for example
<code>foo.bar.baz</code>.</p>
<p>When the <a class="crossref" href="../observe/PathObserver.html#values">values</a> stream is being listened to, this will observe changes to
the object and any intermediate object along the path, and send <a class="crossref" href="../observe/PathObserver.html#values">values</a>
accordingly. When all listeners are unregistered it will stop observing
the objects.</p>
<p>This class is used to implement <code>Node.bind</code> and similar functionality.</p>
<pre class="source">
class PathObserver {
 /** The object being observed. */
 final object;

 /** The path string. */
 final String path;

 /** True if the path is valid, otherwise false. */
 final bool _isValid;

 // TODO(jmesserly): same issue here as ObservableMixin: is there an easier
 // way to get a broadcast stream?
 StreamController _values;
 Stream _valueStream;

 _PropertyObserver _observer, _lastObserver;

 Object _lastValue;
 bool _scheduled = false;

 /**
  * Observes [path] on [object] for changes. This returns an object that can be
  * used to get the changes and get/set the value at this path.
  * See [PathObserver.values] and [PathObserver.value].
  */
 PathObserver(this.object, String path)
   : path = path, _isValid = _isPathValid(path) {

   // TODO(jmesserly): if the path is empty, or the object is! Observable, we
   // can optimize the PathObserver to be more lightweight.

   _values = new StreamController.broadcast(sync: true,
                                            onListen: _observe,
                                            onCancel: _unobserve);

   if (_isValid) {
     var segments = [];
     for (var segment in path.trim().split('.')) {
       if (segment == '') continue;
       var index = int.parse(segment, onError: (_) {});
       segments.add(index != null ? index : new Symbol(segment));
     }

     // Create the property observer linked list.
     // Note that the structure of a path can't change after it is initially
     // constructed, even though the objects along the path can change.
     for (int i = segments.length - 1; i &gt;= 0; i--) {
       _observer = new _PropertyObserver(this, segments[i], _observer);
       if (_lastObserver == null) _lastObserver = _observer;
     }
   }
 }

 // TODO(jmesserly): we could try adding the first value to the stream, but
 // that delivers the first record async.
 /**
  * Listens to the stream, and invokes the [callback] immediately with the
  * current [value]. This is useful for bindings, which want to be up-to-date
  * immediately.
  */
 StreamSubscription bindSync(void callback(value)) {
   var result = values.listen(callback);
   callback(value);
   return result;
 }

 // TODO(jmesserly): should this be a change record with the old value?
 // TODO(jmesserly): should this be a broadcast stream? We only need
 // single-subscription in the bindings system, so single sub saves overhead.
 /**
  * Gets the stream of values that were observed at this path.
  * This returns a single-subscription stream.
  */
 Stream get values =&gt; _values.stream;

 /** Force synchronous delivery of [values]. */
 void _deliverValues() {
   _scheduled = false;

   var newValue = value;
   if (!identical(_lastValue, newValue)) {
     _values.add(newValue);
     _lastValue = newValue;
   }
 }

 void _observe() {
   if (_observer != null) {
     _lastValue = value;
     _observer.observe();
   }
 }

 void _unobserve() {
   if (_observer != null) _observer.unobserve();
 }

 void _notifyChange() {
   if (_scheduled) return;
   _scheduled = true;

   // TODO(jmesserly): should we have a guarenteed order with respect to other
   // paths? If so, we could implement this fairly easily by sorting instances
   // of this class by birth order before delivery.
   queueChangeRecords(_deliverValues);
 }

 /** Gets the last reported value at this path. */
 get value {
   if (!_isValid) return null;
   if (_observer == null) return object;
   _observer.ensureValue(object);
   return _lastObserver.value;
 }

 /** Sets the value at this path. */
 void set value(Object value) {
   // TODO(jmesserly): throw if property cannot be set?
   // MDV seems tolerant of these error.
   if (_observer == null || !_isValid) return;
   _observer.ensureValue(object);
   var last = _lastObserver;
   if (_setObjectProperty(last._object, last._property, value)) {
     // Technically, this would get updated asynchronously via a change record.
     // However, it is nice if calling the getter will yield the same value
     // that was just set. So we use this opportunity to update our cache.
     last.value = value;
   }
 }
}
</pre>
</div>
<div>
<h3>Constructors</h3>
<div class="method"><h4 id="PathObserver">
<button class="show-code">Code</button>
new <strong>PathObserver</strong>(object, String path) <a class="anchor-link" href="#PathObserver"
              title="Permalink to PathObserver.PathObserver">#</a></h4>
<div class="doc">
<p>Observes 
<span class="param">path</span> on 
<span class="param">object</span> for changes. This returns an object that can be
used to get the changes and get/set the value at this path.
See <a class="crossref" href="../observe/PathObserver.html#values">PathObserver.values</a> and <a class="crossref" href="../observe/PathObserver.html#value">PathObserver.value</a>.</p>
<pre class="source">
PathObserver(this.object, String path)
 : path = path, _isValid = _isPathValid(path) {

 // TODO(jmesserly): if the path is empty, or the object is! Observable, we
 // can optimize the PathObserver to be more lightweight.

 _values = new StreamController.broadcast(sync: true,
                                          onListen: _observe,
                                          onCancel: _unobserve);

 if (_isValid) {
   var segments = [];
   for (var segment in path.trim().split('.')) {
     if (segment == '') continue;
     var index = int.parse(segment, onError: (_) {});
     segments.add(index != null ? index : new Symbol(segment));
   }

   // Create the property observer linked list.
   // Note that the structure of a path can't change after it is initially
   // constructed, even though the objects along the path can change.
   for (int i = segments.length - 1; i &gt;= 0; i--) {
     _observer = new _PropertyObserver(this, segments[i], _observer);
     if (_lastObserver == null) _lastObserver = _observer;
   }
 }
}
</pre>
</div>
</div>
</div>
<div>
<h3>Properties</h3>
<div class="field"><h4 id="object">
<button class="show-code">Code</button>
final         <strong>object</strong> <a class="anchor-link"
            href="#object"
            title="Permalink to PathObserver.object">#</a>
        </h4>
        <div class="doc">
<p>The object being observed. </p>
<pre class="source">
final object
</pre>
</div>
</div>
<div class="field"><h4 id="path">
<button class="show-code">Code</button>
final String         <strong>path</strong> <a class="anchor-link"
            href="#path"
            title="Permalink to PathObserver.path">#</a>
        </h4>
        <div class="doc">
<p>The path string. </p>
<pre class="source">
final String path
</pre>
</div>
</div>
<div class="method"><h4 id="value">
<button class="show-code">Code</button>
dynamic <strong>get value</strong> <a class="anchor-link" href="#value"
              title="Permalink to PathObserver.get value">#</a></h4>
<div class="doc">
<p>Gets the last reported value at this path. </p>
<pre class="source">
get value {
 if (!_isValid) return null;
 if (_observer == null) return object;
 _observer.ensureValue(object);
 return _lastObserver.value;
}
</pre>
</div>
</div>
<div class="method"><h4 id="value=">
<button class="show-code">Code</button>
void <strong>set value</strong>(Object value) <a class="anchor-link" href="#value="
              title="Permalink to PathObserver.set value">#</a></h4>
<div class="doc">
<p>Sets the value at this path. </p>
<pre class="source">
void set value(Object value) {
 // TODO(jmesserly): throw if property cannot be set?
 // MDV seems tolerant of these error.
 if (_observer == null || !_isValid) return;
 _observer.ensureValue(object);
 var last = _lastObserver;
 if (_setObjectProperty(last._object, last._property, value)) {
   // Technically, this would get updated asynchronously via a change record.
   // However, it is nice if calling the getter will yield the same value
   // that was just set. So we use this opportunity to update our cache.
   last.value = value;
 }
}
</pre>
</div>
</div>
<div class="field"><h4 id="values">
<button class="show-code">Code</button>
final Stream         <strong>values</strong> <a class="anchor-link"
            href="#values"
            title="Permalink to PathObserver.values">#</a>
        </h4>
        <div class="doc">
<p>Gets the stream of values that were observed at this path.
This returns a single-subscription stream.</p>
<pre class="source">
Stream get values =&gt; _values.stream;
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="bindSync">
<button class="show-code">Code</button>
StreamSubscription <strong>bindSync</strong>(void callback(value)) <a class="anchor-link" href="#bindSync"
              title="Permalink to PathObserver.bindSync">#</a></h4>
<div class="doc">
<p>Listens to the stream, and invokes the 
<span class="param">callback</span> immediately with the
current <a class="crossref" href="../observe/PathObserver.html#value">value</a>. This is useful for bindings, which want to be up-to-date
immediately.</p>
<pre class="source">
StreamSubscription bindSync(void callback(value)) {
 var result = values.listen(callback);
 callback(value);
 return result;
}
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          <div>This page was generated at 2013-07-18 09:40:18.665</div>
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        
